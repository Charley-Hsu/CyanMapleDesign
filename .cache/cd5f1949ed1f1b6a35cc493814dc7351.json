{"dependencies":[{"name":"../util","loc":{"line":1,"column":47}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cookie = undefined;\n\nvar _util = require(\"../util\");\n\nconst pluses = /\\+/g;\n\nfunction encode(s) {\n  return config.raw ? s : encodeURIComponent(s);\n}\n\nfunction decode(s) {\n  return config.raw ? s : decodeURIComponent(s);\n}\n\nfunction stringifyCookieValue(value) {\n  return encode(config.json ? JSON.stringify(value) : String(value));\n}\n\nfunction parseCookieValue(s) {\n  if (s.indexOf('\"') === 0) {\n    // This is a quoted cookie as according to RFC2068, unescape...\n    s = s.slice(1, -1).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\n  }\n\n  try {\n    // Replace server-side written pluses with spaces.\n    // If we can't decode the cookie, ignore it, it's unusable.\n    // If we can't parse the cookie, ignore it, it's unusable.\n    s = decodeURIComponent(s.replace(pluses, ' '));\n    return config.json ? JSON.parse(s) : s;\n  } catch (e) {}\n}\n\nfunction read(s, converter) {\n  let value = config.raw ? s : parseCookieValue(s);\n  return $.isFunction(converter) ? converter(value) : value;\n}\n\nlet config = $.cookie = function (key, value, options) {\n\n  // Write\n\n  if (value !== undefined && !$.isFunction(value)) {\n    options = $.extend({}, config.defaults, options);\n\n    if (typeof options.expires === 'number') {\n      let days = options.expires,\n          t = options.expires = new Date();\n      t.setTime(+t + days * 864e+5);\n    }\n    return document.cookie = [encode(key), '=', stringifyCookieValue(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE\n    options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join('');\n  }\n\n  // Read\n\n  let result = key ? undefined : {};\n\n  // To prevent the for loop in the first place assign an empty array\n  // in case there are no cookies at all. Also prevents odd result when\n  // calling $.cookie().\n  let cookies = document.cookie ? document.cookie.split('; ') : [];\n\n  for (let i = 0, l = cookies.length; i < l; i++) {\n\n    let parts = cookies[i].split('=');\n    let name = decode(parts.shift());\n    let cookie = parts.join('=');\n\n    if (key && key === name) {\n      // If second argument (value) is a function it's a converter...\n      result = read(cookie, value);\n      //break;\n    }\n\n    // Prevent storing a cookie that we couldn't decode.\n    if (!key && (cookie = read(cookie)) !== undefined) {\n      result[name] = cookie;\n    }\n  }\n  return result;\n};\n\nconfig.defaults = {};\n\n$.removeCookie = function (key, options) {\n  if ($.cookie(key) === undefined) {\n    return false;\n  }\n\n  // Must not alter options, thus extending a fresh object...\n  $.cookie(key, '', $.extend({}, options, { expires: -1 }));\n  return !$.cookie(key);\n};\n/*---------- copy jquery.cookie end----------------*/\n\nconst cookie = function () {\n  if (arguments[2] && (0, _util.isObject)(arguments[2])) {\n    if ((0, _util.isTimeStr)(arguments[2]['expires'])) {\n      arguments[2]['expires'] = new Date(new Date().getTime() + (0, _util.formatTimeStr)(arguments[2]['expires']));\n    }\n  }\n  return $.cookie.apply(this, arguments);\n};\ncookie.remove = function () {\n  return $.removeCookie.apply(this, arguments);\n};\n\nexports.cookie = cookie;"},"hash":"63e12c5760222411c7f1b23c34707167"}